#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import time
from datetime import datetime

# 设置默认入口文件
ENTRY = "classification_experiment_entry.py"


def check_env():
    """检查是否在 Conda 或 Poetry 环境中"""
    if "CONDA_DEFAULT_ENV" in os.environ:
        env_name = os.environ["CONDA_DEFAULT_ENV"]
        print(f"Conda environment detected: {env_name}")

        # 检查是否在 base 环境
        if env_name == "base":
            switch_to_torch_ml = input(
                "You are currently in the 'base' environment. It is recommended to switch to 'torch_ml' environment.\n"
                "Please run_classification_experiment `conda activate torch_ml` and re-run_classification_experiment the script, or press 'Enter' to continue in the base "
                "environment:"
            )
            if switch_to_torch_ml.lower() not in ['y', 'yes', '']:
                sys.exit("Please switch to 'torch_ml' environment and restart the script.")
        return "conda"

    # 检查 Poetry 环境
    try:
        result = subprocess.run(["poetry", "env", "info"], capture_output=True, text=True)
        if result.returncode == 0:
            print("Poetry environment detected")
            return "poetry"
    except FileNotFoundError:
        pass

    print("No Conda or Poetry environment detected. Please activate an environment.")
    sys.exit(1)


def get_log_filename(experiment_type: str) -> str:
    """根据实验类型和当前日期生成日志文件名"""
    date_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"log_{experiment_type}_{date_str}.log"


def main():
    parser = argparse.ArgumentParser(description="启动实验脚本")
    parser.add_argument("-E", "--experiment", type=str, required=False,
                        choices=["ltidl", "speidl", "ltari", "sdp"],
                        help="Specify the experiment type.")
    parser.add_argument("--all", action="store_true", help="Run all experiments one by one in sequence.")
    parser.add_argument("-m", "--monitor", action="store_true",
                        help="Clear screen and monitor the log file with 'tail -f'")
    parser.add_argument("-pf", "--profiling", action="store_true", default=False, help="Run train with profiling"),
    parser.add_argument("-okbe", "--only-keep-best-epoch", action="store_true", default=False, help="只保留最好的epoch")

    args = parser.parse_args()

    # 检查环境
    env_type = check_env()

    # 确定实验列表
    experiment_list = []
    if args.all:
        experiment_list = ["ltidl", "speidl", "ltari", "sdp"]
    elif args.experiment:
        experiment_list = [args.experiment]
    else:
        print("Please specify an experiment with -E or use --all to run all.")
        sys.exit(1)

    log_filenames = []
    for experiment in experiment_list:
        log_filename = get_log_filename(experiment)
        print(f"Starting experiment '{experiment}' logging to {log_filename}")
        command = ["python", "-u", ENTRY, "-E", experiment]
        if args.profiling:
            command.append("--profiling")
        if args.only_keep_best_epoch:
            command.append("-okbe")

        with open(log_filename, "w") as log_file:
            if env_type == "conda":
                process = subprocess.Popen(command, stdout=log_file, stderr=log_file)
            elif env_type == "poetry":
                process = subprocess.Popen(["poetry", "run"] + command, stdout=log_file, stderr=log_file)
            else:
                sys.exit(1)
            process.wait()

        log_filenames.append(log_filename)

    # 如果启用了监视选项，则清屏并启动监视
    if args.monitor:
        time.sleep(1)  # 确保日志文件开始写入
        os.system("cls" if os.name == "nt" else "clear")  # Windows: cls, Linux/Mac: clear
        for log_filename in log_filenames:
            subprocess.Popen(["tail", "-f", log_filename], start_new_session=True)


if __name__ == "__main__":
    main()
