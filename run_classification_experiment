#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
import time
from datetime import datetime

# 设置默认入口文件
ENTRY = "classification_experiment_entry.py"


def check_env():
    """检查是否在 Conda 或 Poetry 环境中"""
    if "CONDA_DEFAULT_ENV" in os.environ:
        env_name = os.environ["CONDA_DEFAULT_ENV"]
        print(f"Conda environment detected: {env_name}")

        # 检查是否在 base 环境
        if env_name == "base":
            switch_to_torch_ml = input(
                "You are currently in the 'base' environment. It is recommended to switch to 'torch_ml' environment.\n"
                "Please run_classification_experiment `conda activate torch_ml` and re-run_classification_experiment the script, or press 'Enter' to continue in the base "
                "environment:"
            )
            if switch_to_torch_ml.lower() not in ['y', 'yes', '']:
                sys.exit("Please switch to 'torch_ml' environment and restart the script.")
        return "conda"

    # 检查 Poetry 环境
    try:
        result = subprocess.run(["poetry", "env", "info"], capture_output=True, text=True)
        if result.returncode == 0:
            print("Poetry environment detected")
            return "poetry"
    except FileNotFoundError:
        pass

    print("No Conda or Poetry environment detected. Please activate an environment.")
    sys.exit(1)


def get_log_filename(experiment_type: str) -> str:
    """根据实验类型和当前日期生成日志文件名"""
    date_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"log_{experiment_type}_{date_str}.log"


def main():
    parser = argparse.ArgumentParser(description="启动实验脚本")
    parser.add_argument("-E", "--experiment", type=str, required=True,
                        choices=["ltidl", "speidl", "ltari", "sdp"],
                        help="Specify the experiment type.")
    parser.add_argument("-m", "--monitor", action="store_true",
                        help="Clear screen and monitor the log file with 'tail -f'")
    parser.add_argument("-pf", "--profiling", action="store_true", default=False, help="Run train with profiling"),
    parser.add_argument("-okbe", "--only-keep-best-epoch", action="store_true", default=False, help="只保留最好的epoch")

    args = parser.parse_args()

    # 生成日志文件名
    log_filename = get_log_filename(args.experiment)

    # 检查环境
    env_type = check_env()

    # 启动实验
    print(f"Starting experiment '{args.experiment}'logging to {log_filename}")
    command = ["nohup", "python", "-u", ENTRY, "-E", args.experiment]
    if args.profiling:
        command.append("--profiling")
    if args.only_keep_best_epoch:
        command.append("-okbe")

    if env_type == "conda":
        # 使用 nohup 启动 Conda 环境中的脚本，且子进程与父进程分离
        with open(log_filename, "w") as log_file:
            subprocess.Popen(
                command, stdout=log_file, stderr=log_file, start_new_session=True
            )
    elif env_type == "poetry":
        # 使用 nohup 启动 Poetry 环境中的脚本，且子进程与父进程分离
        with open(log_filename, "w") as log_file:
            subprocess.Popen(
                ["nohup", "poetry", "run"] + command[1:], stdout=log_file, stderr=log_file, start_new_session=True
            )

    # 如果启用了监视选项，则清屏并启动监视
    if args.monitor:
        time.sleep(1)  # 确保日志文件开始写入
        os.system("cls" if os.name == "nt" else "clear")  # Windows: cls, Linux/Mac: clear
        # 启动 tail 进程监控日志
        subprocess.Popen(["tail", "-f", log_filename], start_new_session=True)


if __name__ == "__main__":
    main()
